#' Expand an alphanumeric range into a tibble
#'
#' @description
#' Expand a tibble with row and col from an alphanumeric range with the `:` notation, e.g. A1:A3
#' @concept helper
#'
#' @param alphanumeric_range A character string specifying an alphanumeric range using `:` notation
#'
#' @return A \link[tibble]{tibble} with row, col
#' @export
#'
#' @examples alphanumeric_tbl("A1:C3")
alphanumeric_tbl <- function(alphanumeric_range) {
  rows <- stringr::str_extract_all(alphanumeric_range, "[A-Z]+")[[1]] |>
    paste0(collapse = ":") |>
    letter_seq()
  cols <- tryCatch(
    stringr::str_extract_all(alphanumeric_range, "[0-9]+")[[1]] |>
      as.numeric() |>
      {
        \(x) do.call(seq, if (length(x) > 1) as.list(x) else as.list(c(x, x)))
      }(),
    error = function(e) cli::cli_abort("Wells contain NA.")
  )
  return(tidyr::expand_grid(row = rows, col = cols))
}


#' Equally linearly-spaced numbers
#'
#' @description
#' Generate a numeric vector of equally spaced numbers
#' between a minimum and maximum on a linear scale
#' @concept helper
#'
#'
#' @param x1 Minimum number
#' @param x2 Maximum number
#' @param n Length of the resulting vector
#'
#' @return Numeric vector of length n
#' @export
linspace <- function(x1, x2, n = 100) {
  stopifnot(is.numeric(x1), is.numeric(x2), length(x1) == 1, length(x2) == 1)
  n <- floor(n)
  if (n <= 1) x2 else seq(x1, x2, length.out = n)
}


#' Equally log-spaced numbers
#'
#' @description
#' Generate a numeric vector of equally spaced numbers
#' between a minimum and maximum on a log scale
#' @concept helper
#'
#' @param x1 Minimum number
#' @param x2 Maximum number
#' @param n Length of the resulting vector
#'
#' @return Numeric vector of length n
#' @export
logspace <- function(x1, x2, n = 100) {
  return(exp(linspace(log(x1), log(x2), n)))
}


#' Identify duplicated rows
#'
#' @description
#' Return duplicated rows of a tibble based on a set of identifying columns
#' @concept helper
#'
#' @param tbl A \link[tibble]{tibble}
#' @param id_cols <[`tidy-select`][dplyr_tidy_select]> Name of identifying column(s)
#'
#' @return A \link[tibble]{tibble} of duplicated rows
#' @export
duplicated_rows <- function(tbl, id_cols) {
  dup <- tbl |>
    dplyr::summarise(n = dplyr::n(), .by = {{ id_cols }}) |>
    dplyr::filter(n > 1) |>
    dplyr::ungroup()
  return(dup)
}


#' Clear R.cache
#'
#' @description
#' Clear temporary files from `R.cache::getCachePath()` generated by R.cache.
#' @concept helper
#'
#' @export
clearCache <- function() {
  rlang::check_installed("rlang", reason = "to use `clearCache()`")
  R.cache::clearCache(prompt = FALSE)
}


#' Activate R.cache
#'
#' @description
#' Use caching and write temporary files to `R.cache::getCachePath()`.
#' @concept helper
#'
#' @export
activateCache <- function() {
  rlang::check_installed("rlang", reason = "to use `activateCache()`")
  clearCache()
  options(R.cache.enabled = TRUE)
  cli::cli_alert_info("R.cache enabled")
}


#' Deactivate R.cache
#'
#' @description
#' Don't use caching and don't write temporary files to `R.cache::getCachePath()`.
#' @concept helper
#'
#' @export
deactivateCache <- function() {
  rlang::check_installed("rlang", reason = "to use `deactivateCache()`")
  clearCache()
  options(R.cache.enabled = FALSE)
  cli::cli_alert_info("R.cache deactivated")
}


#' Status of R.cache
#'
#' @description
#' Enquire the status of caching and return the number of key files from `R.cache::getCachePath()`.
#' @concept helper
#'
#' @export
statusCache <- function() {
  rlang::check_installed("rlang", reason = "to use `statusCache()`")
  status <- ifelse(isTRUE(getOption("R.cache.enabled")), "on", "off")
  cli::cli_alert_info("Caching is {status}")
  n_cached_files <- length(list.files(R.cache::getCachePath(), "*.Rcache"))
  cli::cli_alert_info("{n_cached_files} key files are in the cache")
}


#' Get file type
#'
#' @description
#' Get file type based on file extension.
#' @concept helper
#'
#' @param filename Character string specifying the filename
#'
#' @return Character string specifying the file type (`img`, `doc`, `NA`)
#' @export
get_file_type <- function(filename) {
  ext <- tools::file_ext(filename)
  if (ext == "docx") {
    return("doc")
  } else if (ext %in% c("png", "jpg", "jpeg", "tiff")) {
    return("img")
  } else {
    return(NA)
  }
}


#' Convert tibble into flextable
#'
#' @description
#' Convert a tibble into a flextable with custom formatting.
#' @concept helper
#'
#' @param tbl A \link[tibble]{tibble}
#' @param autofit_part Character string specifying how to fit column widths ("all", "body", "header" or "footer")
#' @param save Boolean indicating whether to save the flextable
#' @param filename Character string specifying the filename
#'
#' @return A \link[flextable]{flextable}
#' @export
as_flextable <- function(
  tbl,
  autofit_part = "header",
  save = FALSE,
  filename = NULL
) {
  flex_tbl <- flextable::flextable(tbl) |>
    flextable::bold(bold = TRUE, part = "header") |>
    flextable::bg(bg = "#EFEFEF", part = "header") |>
    flextable::fontsize(size = 9, part = "all") |>
    flextable::font(fontname = "Arial", part = "all") |>
    flextable::padding(padding.top = 3, padding.bottom = 3, part = "all") |>
    flextable::autofit(part = autofit_part) |>
    flextable::border_outer(border = NULL, part = "all") |>
    flextable::fontsize(size = 8, part = "footer") |>
    flextable::line_spacing(space = 0.3, part = "footer")

  if (save == TRUE) {
    if (is.null(filename)) {
      filename <- "flextable.png"
    }
    if (get_file_type(filename) == "doc") {
      flextable::save_as_docx(
        flex_tbl,
        path = filename
      )
    } else {
      flextable::save_as_image(flex_tbl, filename, res = 300)
    }
  }
  return(flex_tbl)
}


#' Get next ID
#'
#' @description
#' Get the next ID from the primary key column of a database table
#' @concept helper
#'
#' @param con A \link[DBI]{DBIConnection-class} object to a DRP database
#' @param tbl A character string specifying the database table name
#' @param pk A character string specifying the primary key column name (if `NULL` look up the pk in the database)
#' @param exclude A numeric vector of IDs in the primary key to exclude from the search
#' @param named A logical indicating whether to return a named vector with the primary key name
#'
#' @return An integer or named vector specifying the next free ID
#' @export
next_id <- function(con, tbl, pk = NULL, exclude = NULL, named = FALSE) {
  if (is.null(pk)) {
    pk_query <- "
      SELECT kcu.column_name
      FROM information_schema.table_constraints tc
      JOIN information_schema.key_column_usage kcu
        ON tc.constraint_name = kcu.constraint_name
        AND tc.table_schema = kcu.table_schema
      WHERE tc.constraint_type = 'PRIMARY KEY'
        AND tc.table_name = $1
        AND tc.table_schema = 'public';
      "
    pk <- pool::dbGetQuery(con, pk_query, params = list(tbl))$column_name
  }
  if (length(pk) == 0) {
    cli::cli_abort("Table '{tbl}' does not exist.")
  } else if (length(pk) > 1) {
    cli::cli_alert_info(
      "Table '{tbl}' has a composite key. Returning the last composite key instead."
    )
    order_by <- paste(
      glue::glue_sql("{`pk`} DESC", .con = con),
      collapse = ", "
    )
    pks <- paste(glue::glue_sql("{`pk`}", .con = con), collapse = ", ")
    id <- pool::dbGetQuery(
      con,
      glue::glue_sql(
        "SELECT {DBI::SQL(pks)} FROM {`tbl`} ORDER BY {DBI::SQL(order_by)} LIMIT 1;",
        .con = con
      )
    )
  } else {
    id <- max(
      pool::dbGetQuery(
        con,
        glue::glue_sql("SELECT MAX({`pk`}) AS max_id FROM {`tbl`};", .con = con)
      )$max_id,
      0,
      exclude,
      na.rm = TRUE
    ) +
      1
  }
  if (named) {
    return(setNames(id, pk))
  } else {
    id
  }
}
